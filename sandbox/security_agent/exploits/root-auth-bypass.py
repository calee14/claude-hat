#!/usr/bin/env python3
import requests
import json
import sys

def exploit():
    # Initialize result structure
    result = {
        "vulnerability_id": "root-auth-bypass",
        "target_url": "http://localhost:3000",
        "test_type": "Authentication Bypass",
        "vulnerable": False,
        "evidence": {},
        "error": None
    }
    
    try:
        # Test 1: Access root endpoint without any authentication
        # This is a non-destructive GET request to check if authentication is required
        response = requests.get(
            "http://localhost:3000/",
            timeout=10,
            allow_redirects=False  # Don't follow redirects to catch auth redirects
        )
        
        # Store response details for analysis
        result["evidence"]["status_code"] = response.status_code
        result["evidence"]["headers"] = dict(response.headers)
        result["evidence"]["response_length"] = len(response.text)
        
        # Check if we can access content without authentication
        # Look for indicators that suggest successful access without auth
        content_indicators = [
            len(response.text) > 100,  # Non-trivial content returned
            response.status_code == 200,  # Successful response
            "login" not in response.text.lower(),  # No login prompt in content
            "unauthorized" not in response.text.lower(),  # No unauthorized message
            "forbidden" not in response.text.lower()  # No forbidden message
        ]
        
        # Check for auth-related headers that might indicate protection
        auth_headers = [
            "www-authenticate" in response.headers,
            "location" in response.headers and any(auth_word in response.headers.get("location", "").lower() 
                                                  for auth_word in ["login", "auth", "signin"])
        ]
        
        # Analyze response to determine if authentication bypass exists
        if response.status_code == 200:
            # Got successful response - check if it contains actual content or just a login page
            if any(word in response.text.lower() for word in ["dashboard", "welcome", "home", "main", "app"]):
                result["vulnerable"] = True
                result["evidence"]["vulnerability_details"] = "Root endpoint accessible without authentication, contains application content"
            elif any(word in response.text.lower() for word in ["login", "signin", "authenticate"]):
                result["vulnerable"] = False
                result["evidence"]["vulnerability_details"] = "Root endpoint returns login page, authentication appears required"
            else:
                # Ambiguous case - got 200 but unclear content
                result["vulnerable"] = True if len(response.text) > 500 else False
                result["evidence"]["vulnerability_details"] = f"Root endpoint returned {len(response.text)} bytes of content without authentication"
        
        elif response.status_code in [401, 403]:
            # Authentication/authorization required
            result["vulnerable"] = False
            result["evidence"]["vulnerability_details"] = f"Authentication required - received {response.status_code} status"
            
        elif response.status_code in [302, 301, 307, 308]:
            # Redirect - check if it's to an auth page
            location = response.headers.get("location", "")
            if any(auth_word in location.lower() for auth_word in ["login", "auth", "signin"]):
                result["vulnerable"] = False
                result["evidence"]["vulnerability_details"] = f"Redirected to authentication page: {location}"
            else:
                result["vulnerable"] = True
                result["evidence"]["vulnerability_details"] = f"Unexpected redirect without authentication: {location}"
                
        else:
            # Other status codes
            result["vulnerable"] = False
            result["evidence"]["vulnerability_details"] = f"Unexpected response: {response.status_code}"
        
        # Additional test: Try to access with malformed/empty auth headers
        # This helps confirm the authentication bypass
        if result["vulnerable"]:
            test_response = requests.get(
                "http://localhost:3000/",
                headers={"Authorization": ""},
                timeout=10,
                allow_redirects=False
            )
            result["evidence"]["empty_auth_header_status"] = test_response.status_code
            
    except requests.exceptions.ConnectionError:
        result["error"] = "Connection failed - target server may be down"
    except requests.exceptions.Timeout:
        result["error"] = "Request timeout - server did not respond in time"
    except requests.exceptions.RequestException as e:
        result["error"] = f"Request failed: {str(e)}"
    except Exception as e:
        result["error"] = f"Unexpected error: {str(e)}"
    
    return result

if __name__ == "__main__":
    result = exploit()
    print(json.dumps(result, indent=2))